#version 430 core

struct Entry {
	int index;
	uint key;
};

layout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;

layout(std430, binding = 2) buffer PredictedPositions { vec4 predictedPositions[]; };
layout(std430, binding = 4) buffer Densities { float densities[]; };
layout(std430, binding = 5) buffer NearDensities { float nearDensities[]; };
layout(std430, binding = 6) buffer SpatialLookup { Entry spatialLookup[]; };
layout(std430, binding = 7) buffer StartIndices { uint startIndices[]; };
layout(std430, binding = 8) buffer SimulationParameters {   
    float dt;
    float gravityAcceleration;
    float mass;
    float collisionDamping;
    float smoothingRadius;
    float targetDensity;
    float pressureMultiplier;
    float viscosityStrength;
    float nearDensityMultiplier;
    
    uint isInteracting;
    uint isPaused;
    float inputPositionX;
    float inputPositionY;
    float inputPositionZ;
    float interactionRadius;
    float interactionStrength;

    uint particleCount;
    uint hashSize;
    float spacing;
    float particleRadius;
    float boundaryX;
    float boundaryY;
    float boundaryZ;
};

// Math constants
const uint MAX_INT = 0xffffffffu;
const float PI = 3.14159265359f;
const float EPSILON = 1e-6f;



const ivec2 cellOffsets[9] = ivec2[9](
    ivec2(0, 0), ivec2(1, 0), ivec2(0, 1),
    ivec2(-1, 0), ivec2(0, -1), ivec2(1, 1),
    ivec2(-1, -1), ivec2(1, -1), ivec2(-1, 1)
);

float SpikyPow2Kernel(float radius, float distance) {  
	if (distance > radius) return 0.0f;

	float v = radius - distance;
    float factor = 15 / (2 * PI * pow(radius, 5));
    return v * v * factor;
}

float SpikyPow3Kernel(float radius, float distance) {  
	if (distance > radius) return 0.0f;

	float v = radius - distance;
    float factor = 15 / (PI * pow(radius, 6));
    return v * v * v * factor;
}

ivec3 PositionsToCellCoord(vec3 point, float radius) {
    return ivec3(
        int(floor(point.x / radius)),
        int(floor(point.y / radius)),
        0
    );
}

uint HashCell(int x, int y) {
    const uint p1 = 73856093u;
    const uint p2 = 19349663u;
    return uint(x) * p1 ^ uint(y) * p2;
}

uint GetKeyFromHash(uint hash) {
    return hash % hashSize;
}

vec2 CalculateDensity(uint i) {
    ivec3 cellCoord = PositionsToCellCoord(predictedPositions[i].xyz, smoothingRadius);
    float density = 0.0;
    float nearDensity = 0.0;

    int centerX = cellCoord.x;
    int centerY = cellCoord.y;
    float sqrRadius = smoothingRadius * smoothingRadius;

    for (int k = 0; k < 9; ++k) {
        int offsetX = cellOffsets[k].x;
        int offsetY = cellOffsets[k].y;

        uint key = GetKeyFromHash(HashCell(centerX + offsetX, centerY + offsetY));
        uint cellStartIndex = uint(startIndices[key]);
        if (cellStartIndex == MAX_INT) continue;

        for (uint j = cellStartIndex; j < spatialLookup.length(); ++j) {
            if (uint(spatialLookup[j].key) != key) break;

            uint particleIndex = uint(spatialLookup[j].index);
            if (particleIndex == i) continue;

            vec3 offset = predictedPositions[particleIndex].xyz - predictedPositions[i].xyz;
            float sqrDistance = dot(offset, offset);

            if (sqrDistance < sqrRadius) {
                float distance = sqrt(sqrDistance);
                density += SpikyPow2Kernel(smoothingRadius, distance) * mass;
                nearDensity += SpikyPow3Kernel(smoothingRadius, distance) * mass;
            }
        }
    }
    return vec2(density, nearDensity);
}

void main() {
    uint i = gl_GlobalInvocationID.x;
    if (i >= particleCount) return;

    vec2 densitiesResult = CalculateDensity(i);
    densities[i] = densitiesResult.x;
    nearDensities[i] = densitiesResult.y;
}