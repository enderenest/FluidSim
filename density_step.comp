#version 430 core

struct Entry {
	int index;
	uint key;
};

struct ParticleVectors {
	vec4 position;
	vec4 predictedPosition;
	vec4 velocity;
};

struct ParticleValues {
	float mass;
	float density;
	float nearDensity;
	uint mergeFlag;
	uint tag; // 0 = KEEP, 1 = SPLIT, 2 = MERGE

	// Padding to ensure the struct is 16 bytes aligned
	float padding1;     
	float padding2;    
	float padding3;  
};

struct SimulationParameters {
	float dt;
	float gravityAcceleration;
	float mass;
	float collisionDamping;
	float smoothingRadius;
	float targetDensity;
	float pressureMultiplier;
	float viscosityStrength;
	float nearDensityMultiplier;
	uint isInteracting;
	uint isPaused;
	float inputPositionX;
	float inputPositionY;
	float inputPositionZ;
	float interactionRadius;
	float interactionStrength;

	uint particleCount;
	uint paddedParticleCount;
	uint hashSize;
	float spacing;
	float particleRadius;
	float boundaryX;
	float boundaryY;
	float boundaryZ;
};

layout(local_size_x = 512, local_size_y = 1, local_size_z = 1) in;

layout(std430, binding = 0) buffer VectorData { ParticleVectors vecData[]; };
layout(std430, binding = 1) buffer ValueData { ParticleValues valData[]; };
layout(std430, binding = 4) buffer SpatialLookup { Entry spatialLookup[]; };
layout(std430, binding = 5) buffer StartIndices { uint startIndices[]; };
layout(std430, binding = 6) buffer SimParamsBuffer { SimulationParameters sim; };

// Math constants
const uint MAX_INT = 0xffffffffu;
const float PI = 3.14159265359f;
const float EPSILON = 1e-6f;


const ivec3 cellOffsets[27] = ivec3[](
    ivec3(0, 0, 0),   ivec3(1, 0, 0),   ivec3(-1, 0, 0), 
    ivec3(0, 1, 0),   ivec3(0, -1, 0),  ivec3(0, 0, 1), 
    ivec3(0, 0, -1),  ivec3(1, 1, 0),   ivec3(-1, -1, 0), 
    ivec3(1, -1, 0),  ivec3(-1, 1, 0),  ivec3(1, 0, 1), 
    ivec3(-1, 0, 1),  ivec3(1, 0, -1),  ivec3(-1, 0, -1),
    ivec3(0, 1, 1),   ivec3(0, -1, 1),  ivec3(0, 1, -1), 
    ivec3(0, -1, -1), ivec3(1, 1, 1),   ivec3(-1, -1, -1), 
    ivec3(1, 1, -1),  ivec3(-1, -1, 1), ivec3(1, -1, 1), 
    ivec3(-1, 1, -1), ivec3(1, -1, -1), ivec3(-1, 1, 1)
);


float SpikyPow2Kernel(float radius, float distance) {  
	if (distance > radius) return 0.0f;

	float v = radius - distance;
    float factor = 15 / (2 * PI * pow(radius, 5));
    return v * v * factor;
}

float SpikyPow3Kernel(float radius, float distance) {  
	if (distance > radius) return 0.0f;

	float v = radius - distance;
    float factor = 15 / (PI * pow(radius, 6));
    return v * v * v * factor;
}

ivec3 PositionsToCellCoord(vec3 point, float radius) {
    return ivec3(
        int(floor(point.x / radius)),
        int(floor(point.y / radius)),
        int(floor(point.z / radius))
    );
}

uint HashCell(int x, int y, int z) {
    const uint p1 = 73856093u;
    const uint p2 = 19349663u;
    const uint p3 = 83492791u;
    return uint(x) * p1 ^ uint(y) * p2 ^ uint(z) * p3;
}

uint GetKeyFromHash(uint hash) {
    return hash % sim.hashSize;
}

vec2 CalculateDensity(uint i) {
    ivec3 cellCoord = PositionsToCellCoord(vecData[i].predictedPosition.xyz, sim.smoothingRadius);
    float density = 0.0;
    float nearDensity = 0.0;

    int centerX = cellCoord.x;
    int centerY = cellCoord.y;
    int centerZ = cellCoord.z;
    float sqrRadius = sim.smoothingRadius * sim.smoothingRadius;

    for (int k = 0; k < 27; ++k) {
        int offsetX = cellOffsets[k].x;
        int offsetY = cellOffsets[k].y;
        int offsetZ = cellOffsets[k].z;

        uint key = GetKeyFromHash(HashCell(centerX + offsetX, centerY + offsetY, centerZ + offsetZ));
        uint cellStartIndex = uint(startIndices[key]);
        if (cellStartIndex == MAX_INT) continue;

        for (uint j = cellStartIndex; j < spatialLookup.length(); ++j) {
            if (uint(spatialLookup[j].key) != key) break;

            uint particleIndex = uint(spatialLookup[j].index);
            if (particleIndex == i) continue;

            vec3 offset = vecData[particleIndex].predictedPosition.xyz - vecData[i].predictedPosition.xyz;
            float sqrDistance = dot(offset, offset);

            if (sqrDistance < sqrRadius) {
                float distance = sqrt(sqrDistance);
                density += SpikyPow2Kernel(sim.smoothingRadius, distance) * sim.mass;
                nearDensity += SpikyPow3Kernel(sim.smoothingRadius, distance) * sim.mass;
            }
        }
    }
    return vec2(density, nearDensity);
}

void main() {
    uint i = gl_GlobalInvocationID.x;
    if (i >= sim.particleCount) return;

    vec2 densitiesResult = CalculateDensity(i);
    valData[i].density = densitiesResult.x;
    valData[i].nearDensity = densitiesResult.y;
}