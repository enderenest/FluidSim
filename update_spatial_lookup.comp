#version 430 core

struct Entry {
	int index;
	uint key;
};

struct ParticleVectors {
	vec4 position;
	vec4 predictedPosition;
	vec4 velocity;
};

struct SimulationParameters {
	float dt;
	float gravityAcceleration;
	float mass;
	float collisionDamping;
	float smoothingRadius;
	float targetDensity;
	float pressureMultiplier;
	float viscosityStrength;
	float nearDensityMultiplier;
	uint isInteracting;
	uint isPaused;
	float inputPositionX;
	float inputPositionY;
	float inputPositionZ;
	float interactionRadius;
	float interactionStrength;

	uint particleCount;
	uint paddedParticleCount;
	uint hashSize;
	float spacing;
	float particleRadius;
	float boundaryX;
	float boundaryY;
	float boundaryZ;
};

layout(local_size_x = 512, local_size_y = 1, local_size_z = 1) in;

layout(std430, binding = 0) buffer VectorData { ParticleVectors vecData[]; };
layout(std430, binding = 4) buffer SpatialLookup { Entry spatialLookup[]; };
layout(std430, binding = 6) buffer SimParamsBuffer { SimulationParameters sim; };

ivec3 PositionToCellCoord(vec3 point, float radius) {
    return ivec3(
        int(floor(point.x / radius)),
        int(floor(point.y / radius)),
        int(floor(point.z / radius))
    );
}

uint HashCell(int x, int y, int z) {
    const uint p1 = 73856093u;
    const uint p2 = 19349663u;
    const uint p3 = 83492791u;
    return uint(x) * p1 ^ uint(y) * p2 ^ uint(z) * p3;
}

uint GetKeyFromHash(uint hash) {
    return hash % sim.hashSize;
}

uint GetKey(vec4 point) {
    vec3 p = point.xyz;
    ivec3 cell = PositionToCellCoord(p, sim.smoothingRadius);
    return GetKeyFromHash(HashCell(cell.x, cell.y, cell.z));
}

void main() {
    uint i = gl_GlobalInvocationID.x;
    if (i >= sim.particleCount) return;

    spatialLookup[i].index = int(i);
    spatialLookup[i].key = GetKey(vecData[i].predictedPosition);
}
