#version 430 core

struct Entry {
	int index;
	uint key;
};

layout(local_size_x = 1024, local_size_y = 1, local_size_z = 1) in;

layout(std430, binding = 2) buffer PredictedPositions { vec4 predictedPositions[]; };
layout(std430, binding = 6) buffer SpatialLookup { Entry spatialLookup[]; };
layout(std430, binding = 8) buffer SimulationParameters { 
    float dt; float gravityAcceleration; float mass; float collisionDamping;
    float smoothingRadius; float targetDensity; float pressureMultiplier;
    float viscosityStrength; float nearDensityMultiplier;
    uint isInteracting; uint isPaused;
    float inputPositionX, inputPositionY, inputPositionZ; 
    float interactionRadius; float interactionStrength;
    uint particleCount; uint hashSize; float spacing;
    float particleRadius; float boundaryX, boundaryY, boundaryZ;
};

ivec3 PositionToCellCoord(vec3 point, float radius) {
    return ivec3(
        int(floor(point.x / radius)),
        int(floor(point.y / radius)),
        0
    );
}

uint HashCell(int x, int y) {
    const uint p1 = 73856093u;
    const uint p2 = 19349663u;
    return uint(x) * p1 ^ uint(y) * p2;
}

uint GetKeyFromHash(uint hash) {
    return hash % hashSize;
}

uint GetKey(vec4 point) {
    vec3 p = point.xyz;
    ivec3 cell = PositionToCellCoord(p, smoothingRadius);
    return GetKeyFromHash(HashCell(cell.x, cell.y));
}

void main() {
    uint i = gl_GlobalInvocationID.x;
    if (i >= particleCount) return;

    spatialLookup[i].index = int(i);
    spatialLookup[i].key = GetKey(predictedPositions[i]);
}
