#version 430 core

struct Entry {
	int index;
	uint key;
};

struct ParticleVectors {
	vec4 position;
	vec4 predictedPosition;
	vec4 velocity;
};

struct ParticleValues {
	float mass;
	float density;
	float nearDensity;
	float particleRadius;
	uint mergeFlag;
	uint tag; // 0 = KEEP, 1 = SPLIT, 2 = MERGE

	// Padding to ensure the struct is 16 bytes aligned
	float padding1;     
	float padding2;
};

struct SimulationParameters {
	float dt;
	float gravityAcceleration;
	float mass;
	float collisionDamping;
	float smoothingRadius;
	float targetDensity;
	float pressureMultiplier;
	float viscosityStrength;
	float nearDensityMultiplier;
	uint isInteracting;
	uint isPaused;
	float inputPositionX;
	float inputPositionY;
	float inputPositionZ;
	float interactionRadius;
	float interactionStrength;

	uint particleCount;
	uint paddedParticleCount;
	uint hashSize;
	float spacing;
	float particleRadius;
	float boundaryX;
	float boundaryY;
	float boundaryZ;
};

layout(local_size_x = 512, local_size_y = 1, local_size_z = 1) in;

// ------------------- Input Buffers ----------------------
layout(std430, binding = 0) buffer VectorData        { ParticleVectors vecData[]; };
layout(std430, binding = 1) buffer ValueData         { ParticleValues valData[]; };
layout(std430, binding = 4) buffer SpatialLookup     { Entry spatialLookup[]; };
layout(std430, binding = 5) buffer StartIndices      { uint startIndices[]; };

// ------------------- Output Buffers ---------------------
layout(std430, binding = 2) buffer NewVectorData     { ParticleVectors newVecData[]; };
layout(std430, binding = 3) buffer NewValueData      { ParticleValues newValData[]; };


layout(std430, binding = 6) buffer SimParamsBuffer { SimulationParameters sim; };
layout(binding = 7, offset = 0) uniform atomic_uint newParticleCounter;

// Math constants
const uint MAX_INT = 0xffffffffu;
const float PI = 3.14159265359f;
const float EPSILON = 1e-6f;


float RandomFloat(uint seed) {
    return fract(sin(float(seed) * 12.9898) * 43758.5453);
}

vec3 GetRandomDirection3D(uint idx) {
    float x = RandomFloat(idx * 928371u) * 2.0 - 1.0; // [-1, 1]
    float y = RandomFloat(idx * 128931u) * 2.0 - 1.0; // [-1, 1]
    float z = RandomFloat(idx * 743281u) * 2.0 - 1.0; // [-1, 1]
    return normalize(vec3(x, y, z));
}

ivec3 PositionsToCellCoord(vec3 point, float radius) {
    return ivec3(
        int(floor(point.x / radius)),
        int(floor(point.y / radius)),
        int(floor(point.z / radius))
    );
}

uint HashCell(int x, int y, int z) {
    const uint p1 = 73856093u;
    const uint p2 = 19349663u;
    const uint p3 = 83492791u;
    return uint(x) * p1 ^ uint(y) * p2 ^ uint(z) * p3;
}

uint GetKeyFromHash(uint hash) {
    return hash % sim.hashSize;
}

void main() {
    uint i = gl_GlobalInvocationID.x;
    if (i >= sim.particleCount) return;

    uint tag = valData[i].tag;
    vec3 pos = vecData[i].position.xyz;
    vec3 vel = vecData[i].velocity.xyz;
    float mass = valData[i].mass;
    float particleRadius = valData[i].particleRadius;

    float splitScale = pow(0.5, 1.0/3.0);
    float mergeScale = pow(2.0, 1.0/3.0);

    // KEEP
    if (tag == 0u) {
        uint id = atomicCounterIncrement(newParticleCounter);
        if (id >= sim.paddedParticleCount) {
            return;
        }
        newVecData[id].position = vec4(pos, 0.0);
        newVecData[id].predictedPosition = vec4(pos + vel * sim.dt, 0.0);
        newVecData[id].velocity = vec4(vel, 0.0);
        newValData[id].mass = mass;
        newValData[id].density = 0.0;
        newValData[id].nearDensity = 0.0;
        newValData[id].particleRadius = particleRadius;
        newValData[id].tag = 0u;
        newValData[id].mergeFlag = 0u; // Reset merge flag
        return;
    }

    // SPLIT
    else if (tag == 1u) {
        vec3 dir = GetRandomDirection3D(i);
        float offsetDist = sim.spacing * 0.5;
        vec3 offset = dir * offsetDist;

        uint id1 = atomicCounterIncrement(newParticleCounter);
        if (id1 >= sim.paddedParticleCount) {
            return;
        }
        newVecData[id1].position = vec4(pos + offset, 0.0);
        newVecData[id1].predictedPosition = vec4(pos + offset + vel * sim.dt, 0.0);
        newVecData[id1].velocity = vec4(vel, 0.0);
        newValData[id1].mass = mass * 0.5;
        newValData[id1].density = 0.0;
        newValData[id1].nearDensity = 0.0;
        newValData[id1].particleRadius = particleRadius * splitScale;
        newValData[id1].tag = 0u;
        newValData[id1].mergeFlag = 0u; // Reset merge flag



        uint id2 = atomicCounterIncrement(newParticleCounter);
        if (id2 >= sim.paddedParticleCount) {
            return;
        }
        newVecData[id2].position = vec4(pos - offset, 0.0);
        newVecData[id2].predictedPosition = vec4(pos - offset + vel * sim.dt, 0.0);
        newVecData[id2].velocity = vec4(vel, 0.0);
        newValData[id2].mass = mass * 0.5;
        newValData[id2].density = 0.0;
        newValData[id2].nearDensity = 0.0;
        newValData[id2].particleRadius = particleRadius * splitScale;
        newValData[id2].tag = 0u;
        newValData[id2].mergeFlag = 0u; // Reset merge flag

        return;
    }

    // MERGE
    else if (tag == 2u) {
        if (atomicCompSwap(valData[i].mergeFlag, 0u, 1u) != 0u) {
            // another thread already grabbed i for merge
            return;
        }

        ivec3 cellCoord = PositionsToCellCoord(pos, sim.smoothingRadius);

        for (int k = 0; k < 27; ++k) {
            ivec3 offset = ivec3(
                int(k % 3) - 1,
                int((k / 3) % 3) - 1,
                int(k / 9) - 1
            );
            ivec3 neighborCell = cellCoord + offset;

            uint key = GetKeyFromHash(HashCell(neighborCell.x, neighborCell.y, neighborCell.z));
            uint cellStart = startIndices[key];
            if (cellStart == MAX_INT) continue;

            for (uint j = cellStart; j < spatialLookup.length(); ++j) {
                if (spatialLookup[j].key != key) break;

                uint neighborIndex = uint(spatialLookup[j].index);
                if (neighborIndex <= i) continue;
                if (valData[neighborIndex].tag != 2u) continue;
                if (atomicCompSwap( valData[neighborIndex].mergeFlag, 0u, 1u ) != 0u) continue;

                vec3 pos2 = vecData[neighborIndex].position.xyz;
                vec3 vel2 = vecData[neighborIndex].velocity.xyz;
                float mass2 = valData[neighborIndex].mass;

                vec3 mergedPos = (mass * pos + mass2 * pos2) / (mass + mass2);
                vec3 mergedVel = (mass * vel + mass2 * vel2) / (mass + mass2);
                float mergedMass = mass + mass2;

                atomicExchange( valData[i].mergeFlag, 1u );

                uint id = atomicCounterIncrement(newParticleCounter);
                newVecData[id].position = vec4(mergedPos, 0.0);
                newVecData[id].predictedPosition = vec4(mergedPos + mergedVel * sim.dt, 0.0);
                newVecData[id].velocity = vec4(mergedVel, 0.0);
                newValData[id].mass = mergedMass;
                newValData[id].density = 0.0;
                newValData[id].nearDensity = 0.0;
                newValData[id].particleRadius = particleRadius * mergeScale;
                newValData[id].tag = 0u;
                newValData[id].mergeFlag = 0u; // Reset merge flag

                return;
            }
        }
    }

    else {
        // If the tag is not recognized, we can just keep the particle as is
        uint id = atomicCounterIncrement(newParticleCounter);

        if (id >= sim.paddedParticleCount) {
            return;
        }

        newVecData[id].position = vec4(pos, 0.0);
        newVecData[id].predictedPosition = vec4(pos, 0.0);
        newVecData[id].velocity = vec4(vel, 0.0);
        newValData[id].mass = mass;
        newValData[id].density = 0.0;
        newValData[id].nearDensity = 0.0;
        newValData[id].particleRadius = particleRadius;
        newValData[id].tag = 0u; // Default to KEEP
        newValData[id].mergeFlag = 0u; // Reset merge flag
    }
}

