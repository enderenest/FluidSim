#version 430 core

layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

// Buffer declarations for particle data
layout(std430, binding = 0) buffer Positions { vec3 positions[]; };
layout(std430, binding = 1) buffer PredictedPositions { vec3 predictedPositions[]; };
layout(std430, binding = 2) buffer Velocities { vec3 velocities[]; };
layout(std430, binding = 3) buffer Densities { float densities[]; };
layout(std430, binding = 4) buffer NearDensities { float nearDensities[]; };
layout(std430, binding = 5) buffer SpatialLookup { float spatialLookup[]; };
layout(std430, binding = 6) buffer StartIndices { float startIndices[]; };

// Uniforms variables that are change dynamically during simulation
uniform float dt;
uniform float gravity;
uniform float mass;
uniform float collisionDamping;
uniform float smoothingRadius;
uniform float targetDensity;
uniform float pressureMultiplier;
uniform float viscosityStrength;
uniform float nearDensityMultiplier;

// Constant values
const uint MAX_INT = 0xffffffffu;
const float PI = 3.14159265359f;
const float EPSILON = 1e-6f;

const unsigned int particleCount = 10000;
const unsigned int hashSize = 32768;
const float spacing = 0.01;
const float particleRadius = 0.05;
const float boundaryX = 0.9f;
const float boundaryY = 0.9f;
const float boundaryZ = 0.9f;

const ivec2 cellOffsets[9] = ivec2[](
    ivec2(0, 0), ivec2(1, 0), ivec2(0, 1),
    ivec2(-1, 0), ivec2(0, -1), ivec2(1, 1),
    ivec2(-1, -1), ivec2(1, -1), ivec2(-1, 1)
);


void main() {
    uint index = gl_GlobalInvocationID.x;
    if (index >= positions.length()) return;

    velocities[idx].y -= gravity * dt; // Apply gravity
    predictedPositions[idx] = positions[idx] + velocities[idx] * dt;

    

}

void HandleBoundaryCollisions(uint index) {
    vec2 halfBounds = vec2(boundaryX  - particleRadius, boundaryY  - particleRadius);

    if (abs(positions[index].x) > halfBounds.x) {
        positions[index].x = halfBounds.x * sign(positions[index].x);
        velocities[index].x *= - collisionDamping;
    }

    if (abs(positions[index].y) > halfBounds.y) {
        positions[index].y = halfBounds.y * sign(positions[index].y);
        velocities[index].y *= - collisionDamping;
    }

    positions[index].z = 0.0f;
}

float SpikyPow2Kernel(float radius, float distance) {  
	if (distance > radius) return 0.0f;

	float v = radius - distance;
    float factor = 15 / (2 * PI * pow(radius, 5));
    return v * v * factor;
}

float SpikyPow2KernelDerivative(float radius, float distance) {
    if (distance > radius) return 0.0f;

    float v = radius - distance;
    float factor = 15 / (PI * pow(radius, 5));
    return -v * factor;
}

float SpikyPow3Kernel(float radius, float distance) {  
	if (distance > radius) return 0.0f;

	float v = radius - distance;
    float factor = 15 / (PI * pow(radius, 6));
    return v * v * v * factor;
}

float SpikyPow3KernelDerivative(float radius, float distance) {  
	if (distance > radius) return 0.0f;

	float v = radius - distance;
    float factor = 45 / (PI * pow(radius, 6));
    return -v * v * factor;
}

float Poly6Kernel(float radius, float distance) {  
	if (distance > radius) return 0.0f;

    float v = max(0.0f, radius * radius - distance * distance);
    float factor = 315 / (64 * PI * pow(abs(radius), 9));
	return v * v * v * factor;
}

float RandomFloat(uint seed) {
    return fract(sin(float(seed) * 12.9898) * 43758.5453);
}

vec3 GetRandomDirection3D(uint idx) {
    float x = RandomFloat(idx * 928371u) * 2.0 - 1.0; // [-1, 1]
    float y = RandomFloat(idx * 128931u) * 2.0 - 1.0; // [-1, 1]
    float z = 0.0f;
    return normalize(vec3(x, y, z));
}

ivec3 PositionsToCellCoord(vec3 point, float radius) {
    return ivec3(
        int(floor(point.x / radius)),
        int(floor(point.y / radius)),
        0
    );
}

uint HashCell(int x, int y) {
    const uint p1 = 73856093u;
    const uint p2 = 19349663u;
    return uint(x) * p1 ^ uint(y) * p2;
}

uint GetKeyFromHash(uint hash) {
    return hash % hashSize;
}

vec2 CalculateDensity(uint i) {
    ivec3 cellCoord = PositionsToCellCoord(predictedPositions[i], smoothingRadius);
    float density = 0.0;
    float nearDensity = 0.0;

    int centerX = cellCoord.x;
    int centerY = cellCoord.y;
    float sqrRadius = smoothingRadius * smoothingRadius;

    for (int k = 0; k < 9; ++k) {
        int offsetX = cellOffsets[k].x;
        int offsetY = cellOffsets[k].y;

        uint key = GetKeyFromHash(HashCell(centerX + offsetX, centerY + offsetY));
        uint cellStartIndex = uint(startIndices[key]);
        if (cellStartIndex == MAX_INT) continue;

        for (uint j = cellStartIndex; j < spatialLookup.length(); ++j) {
            if (uint(spatialLookup[j].key) != key) break;

            uint particleIndex = uint(spatialLookup[j].index);
            if (particleIndex == i) continue;

            vec3 offset = predictedPositions[particleIndex] - predictedPositions[i];
            float sqrDistance = dot(offset, offset);

            if (sqrDistance < sqrRadius) {
                float distance = sqrt(sqrDistance);
                density += SpikyPow2Kernel(smoothingRadius, distance) * mass;
                nearDensity += SpikyPow3Kernel(smoothingRadius, distance) * mass;
            }
        }
    }
    return vec2(density, nearDensity);
}

float DensityToPressure(float density) {
	float densityError = density - targetDensity;
	float pressure = pressureMultiplier * densityError;
    return pressure;
}

float NearDensityToPressure(float nearDensity)
{
    return nearDensityMultiplier * nearDensity;
}

