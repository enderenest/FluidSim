#version 430 core

struct Entry {
	int index;
	uint key;
};

struct ParticleVectors {
	vec4 position;
	vec4 predictedPosition;
	vec4 velocity;
};

struct ParticleValues {
	float mass;
	float density;
	float nearDensity;
	float particleRadius;
	uint mergeFlag;
	uint tag; // 0 = KEEP, 1 = SPLIT, 2 = MERGE

	// Padding to ensure the struct is 16 bytes aligned
	float padding1;     
	float padding2;
};

struct SimulationParameters {
	float dt;
	float gravityAcceleration;
	float mass;
	float collisionDamping;
	float smoothingRadius;
	float targetDensity;
	float pressureMultiplier;
	float viscosityStrength;
	float nearDensityMultiplier;
	uint isInteracting;
	uint isPaused;
	float inputPositionX;
	float inputPositionY;
	float inputPositionZ;
	float interactionRadius;
	float interactionStrength;

	uint particleCount;
	uint paddedParticleCount;
	uint hashSize;
	float spacing;
	float particleRadius;
	float boundaryX;
	float boundaryY;
	float boundaryZ;
};

layout(local_size_x = 512, local_size_y = 1, local_size_z = 1) in;

layout(std430, binding = 0) buffer VectorData { ParticleVectors vecData[]; };
layout(std430, binding = 1) buffer ValueData { ParticleValues valData[]; };
layout(std430, binding = 4) buffer SpatialLookup { Entry spatialLookup[]; };
layout(std430, binding = 5) buffer StartIndices { uint startIndices[]; };
layout(std430, binding = 6) buffer SimParamsBuffer { SimulationParameters sim; };

// Math constants
const uint MAX_INT = 0xffffffffu;
const float PI = 3.14159265359f;
const float EPSILON = 1e-6f;



const ivec3 cellOffsets[27] = ivec3[](
    ivec3(0, 0, 0),   ivec3(1, 0, 0),   ivec3(-1, 0, 0), 
    ivec3(0, 1, 0),   ivec3(0, -1, 0),  ivec3(0, 0, 1), 
    ivec3(0, 0, -1),  ivec3(1, 1, 0),   ivec3(-1, -1, 0), 
    ivec3(1, -1, 0),  ivec3(-1, 1, 0),  ivec3(1, 0, 1), 
    ivec3(-1, 0, 1),  ivec3(1, 0, -1),  ivec3(-1, 0, -1),
    ivec3(0, 1, 1),   ivec3(0, -1, 1),  ivec3(0, 1, -1), 
    ivec3(0, -1, -1), ivec3(1, 1, 1),   ivec3(-1, -1, -1), 
    ivec3(1, 1, -1),  ivec3(-1, -1, 1), ivec3(1, -1, 1), 
    ivec3(-1, 1, -1), ivec3(1, -1, -1), ivec3(-1, 1, 1)
);

float SpikyPow2KernelDerivative(float radius, float distance) {
    if (distance > radius) return 0.0f;

    float v = radius - distance;
    float factor = 15 / (PI * pow(radius, 5));
    return -v * factor;
}

float SpikyPow3KernelDerivative(float radius, float distance) {  
	if (distance > radius) return 0.0f;

	float v = radius - distance;
    float factor = 45 / (PI * pow(radius, 6));
    return -v * v * factor;
}

float Poly6Kernel(float radius, float distance) {  
	if (distance > radius) return 0.0f;

    float v = max(0.0f, radius * radius - distance * distance);
    float factor = 315 / (64 * PI * pow(abs(radius), 9));
	return v * v * v * factor;
}

float RandomFloat(uint seed) {
    return fract(sin(float(seed) * 12.9898) * 43758.5453);
}

vec3 GetRandomDirection3D(uint idx) {
    float x = RandomFloat(idx * 928371u) * 2.0 - 1.0; // [-1, 1]
    float y = RandomFloat(idx * 128931u) * 2.0 - 1.0; // [-1, 1]
    float z = RandomFloat(idx * 743281u) * 2.0 - 1.0; // [-1, 1]
    return normalize(vec3(x, y, z));
}

ivec3 PositionsToCellCoord(vec3 point, float radius) {
    return ivec3(
        int(floor(point.x / radius)),
        int(floor(point.y / radius)),
        int(floor(point.z / radius))
    );
}

uint HashCell(int x, int y, int z) {
    const uint p1 = 73856093u;
    const uint p2 = 19349663u;
    const uint p3 = 83492791u;
    return uint(x) * p1 ^ uint(y) * p2 ^ uint(z) * p3;
}

uint GetKeyFromHash(uint hash) {
    return hash % sim.hashSize;
}

float DensityToPressure(float density) {
	float densityError = density - sim.targetDensity;
	float pressure = sim.pressureMultiplier * densityError;
    return pressure;
}

float NearDensityToPressure(float nearDensity)
{
    return sim.nearDensityMultiplier * nearDensity;
}

float CalculateSharedPressure(float densityA, float densityB) {
    float pressureA = DensityToPressure(densityA);
    float pressureB = DensityToPressure(densityB);
    return (pressureA + pressureB) / 2.0f;
}

float CalculateNearSharedPressure(float densityA, float densityB) {
    float pressureA = NearDensityToPressure(densityA);
    float pressureB = NearDensityToPressure(densityB);
    return (pressureA + pressureB) / 2.0f;
}

vec3 CalculatePressureForce(uint i) {
	vec3 pressureForce = vec3(0.0f);
	ivec3 cellCoord = PositionsToCellCoord(vecData[i].predictedPosition.xyz, sim.smoothingRadius);
    int centerX = cellCoord.x;
	int centerY = cellCoord.y;
    int centerZ = cellCoord.z;
	float sqrRadius = sim.smoothingRadius * sim.smoothingRadius;

    for (int k = 0; k < 27; ++k) {
        int offsetX = cellOffsets[k].x;
        int offsetY = cellOffsets[k].y;
        int offsetZ = cellOffsets[k].z;

		uint key = GetKeyFromHash(HashCell(centerX + offsetX, centerY + offsetY, centerZ + offsetZ));
		uint cellStartIndex = startIndices[key];
		if (cellStartIndex == MAX_INT) continue;

        for (uint j = cellStartIndex; j < spatialLookup.length(); ++j) {
            if (spatialLookup[j].key != key) break;
			
			int particleIndex = spatialLookup[j].index;
            if (particleIndex == i) continue;

			vec3 offset = vecData[particleIndex].predictedPosition.xyz - vecData[i].predictedPosition.xyz;
			float sqrDistance = dot(offset, offset);

            if (sqrDistance < sqrRadius) {
				float distance = sqrt(sqrDistance);
                vec3 direction = (distance == 0) ? GetRandomDirection3D(particleIndex) : offset / distance;
                float slope = SpikyPow2KernelDerivative(sim.smoothingRadius, distance);
				float nearSlope = SpikyPow3KernelDerivative(sim.smoothingRadius, distance);
                float density = valData[particleIndex].density;
				float nearDensity = valData[particleIndex].nearDensity;
                float mass = valData[particleIndex].mass;
				float sharedPressure = CalculateSharedPressure(valData[i].density, density); 
				float sharedNearPressure = CalculateNearSharedPressure(valData[i].nearDensity, nearDensity);
                pressureForce += sharedPressure * slope * direction * mass / density;
                pressureForce += sharedNearPressure * nearSlope * direction * mass / nearDensity;
			}
		}
    }

	return pressureForce;
}

vec3 CalculateViscosityForce(uint i) {
    vec3 viscosityForce = vec3(0.0);
    ivec3 cellCoord = PositionsToCellCoord(vecData[i].predictedPosition.xyz, sim.smoothingRadius);
    int centerX = cellCoord.x;
    int centerY = cellCoord.y;
    int centerZ = cellCoord.z;
    float sqrRadius = sim.smoothingRadius * sim.smoothingRadius;
    for (int k = 0; k < 27; ++k) {
        int offsetX = cellOffsets[k].x;
        int offsetY = cellOffsets[k].y;
        int offsetZ = cellOffsets[k].z;
        uint key = GetKeyFromHash(HashCell(centerX + offsetX, centerY + offsetY, centerZ + offsetZ));
        uint cellStartIndex = startIndices[key];
        if (cellStartIndex == MAX_INT) continue;
        for (uint j = cellStartIndex; j < spatialLookup.length(); ++j) {
            if (spatialLookup[j].key != key) break;
            int particleIndex = spatialLookup[j].index;
            if (particleIndex == i) continue;

            vec3 offset = vecData[particleIndex].predictedPosition.xyz - vecData[i].predictedPosition.xyz;
            float sqrDistance = dot(offset, offset);
            if (sqrDistance < sqrRadius) {
                float distance = sqrt(sqrDistance);
				float influence = Poly6Kernel(sim.smoothingRadius, distance);
                viscosityForce += (vecData[particleIndex].velocity.xyz - vecData[i].velocity.xyz) * influence;
            }
        }
    }

	return viscosityForce * sim.viscosityStrength;
}

vec3 ComputeInteractionAccel(vec3 pos, vec3 vel) {
    if (sim.isInteracting == 0u || sim.isPaused != 0u) return vec3(0.0);

    float sqrR   = sim.interactionRadius * sim.interactionRadius;
    vec3  offset = vec3(sim.inputPositionX, sim.inputPositionY, sim.inputPositionZ) - pos;
    float sqrD   = dot(offset, offset);
    if (sqrD >= sqrR) {
        return vec3(0.0);
    }

    float dist    = sqrt(sqrD);
    float edgeT   = dist / sim.interactionRadius; 
    float centreT = 1.0 - edgeT;             

    vec3 dir = (dist > EPSILON) ? (offset / dist) : vec3(0.0);

    return dir * (centreT * sim.interactionStrength)
         - vel * centreT;
}

void ApplyInteractionForce(uint i) {
    if (sim.isInteracting == 0u || sim.isPaused != 0u) return;

    vec3 pos = vecData[i].position.xyz;
    vec3 vel = vecData[i].velocity.xyz;

    vec3 accel = ComputeInteractionAccel(pos, vel);
    vecData[i].velocity.xyz += accel * sim.dt;
}

void main() {
    uint index = gl_GlobalInvocationID.x;
    if (index >= sim.particleCount) return;

    vec3 pressureAcceleration = valData[index].density < EPSILON ? vec3(0.0) : CalculatePressureForce(index) / valData[index].density;
    vec3 viscosityAcceleration = valData[index].density < EPSILON ? vec3(0.0) : CalculateViscosityForce(index) / valData[index].density;

    if (sim.isInteracting != 0u && sim.isPaused == 0u) {
        ApplyInteractionForce(index);
    }

    vec3 totalAcceleration = pressureAcceleration + viscosityAcceleration;

    vecData[index].velocity += vec4(totalAcceleration, 0.0) * sim.dt;
}


