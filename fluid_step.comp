#version 430 core

struct Entry {
    int index;
    uint key;
};

struct ParticleVectors {
	vec4 position;
	vec4 predictedPosition;
	vec4 velocity;
};

struct SimulationParameters {
	float dt;
	float gravityAcceleration;
	float mass;
	float collisionDamping;
	float smoothingRadius;
	float targetDensity;
	float pressureMultiplier;
	float viscosityStrength;
	float nearDensityMultiplier;
	uint isInteracting;
	uint isPaused;
	float inputPositionX;
	float inputPositionY;
	float inputPositionZ;
	float interactionRadius;
	float interactionStrength;

	uint particleCount;
	uint paddedParticleCount;
	uint hashSize;
	float spacing;
	float particleRadius;
	float boundaryX;
	float boundaryY;
	float boundaryZ;
};

layout(local_size_x = 512, local_size_y = 1, local_size_z = 1) in;

layout(std430, binding = 0) buffer VectorData { ParticleVectors vecData[]; };
layout(std430, binding = 8) buffer SimParamsBuffer { SimulationParameters sim; };

// Math constants
const uint MAX_INT = 0xffffffffu;
const float PI = 3.14159265359f;
const float EPSILON = 1e-6f;


void HandleBoundaryCollisions(uint index) {
    vec3 halfBounds = vec3(sim.boundaryX  - sim.particleRadius, 
                           sim.boundaryY  - sim.particleRadius,
                           sim.boundaryZ  - sim.particleRadius);

    if (abs(vecData[index].position.x) > halfBounds.x) {
        vecData[index].position.x = halfBounds.x * sign(vecData[index].position.x);
        vecData[index].velocity.x *= - sim.collisionDamping;
    }

    if (abs(vecData[index].position.y) > halfBounds.y) {
        vecData[index].position.y = halfBounds.y * sign(vecData[index].position.y);
        vecData[index].velocity.y *= - sim.collisionDamping;
    }

    if (abs(vecData[index].position.z) > halfBounds.z) {
        vecData[index].position.z = halfBounds.z * sign(vecData[index].position.z);
        vecData[index].velocity.z *= - sim.collisionDamping;
    }

    vecData[index].position.w = 0.0f;
}

void main() {
    uint index = gl_GlobalInvocationID.x;
    if (index >= sim.particleCount) return;

    vecData[index].position += vecData[index].velocity * sim.dt;
    HandleBoundaryCollisions(index);
}
