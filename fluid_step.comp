#version 430 core

struct Entry {
    int index;
    uint key;
};

layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

// Buffer declarations for particle data
layout(std430, binding = 1) buffer Positions { vec4 positions[]; };
layout(std430, binding = 3) buffer Velocities { vec4 velocities[]; };
layout(std430, binding = 8) buffer SimulationParameters {
    float dt;
    float gravityAcceleration;
    float mass;
    float collisionDamping;
    float smoothingRadius;
    float targetDensity;
    float pressureMultiplier;
    float viscosityStrength;
    float nearDensityMultiplier;
    
    uint isInteracting;
    uint isPaused;
    float inputPositionX;
    float inputPositionY;
    float inputPositionZ;
    float interactionRadius;
    float interactionStrength;

    uint particleCount;
    uint hashSize;
    float spacing;
    float particleRadius;
    float boundaryX;
    float boundaryY;
    float boundaryZ;
};

// Math constants
const uint MAX_INT = 0xffffffffu;
const float PI = 3.14159265359f;
const float EPSILON = 1e-6f;


void HandleBoundaryCollisions(uint index) {
    vec2 halfBounds = vec2(boundaryX  - particleRadius, boundaryY  - particleRadius);

    if (abs(positions[index].x) > halfBounds.x) {
        positions[index].x = halfBounds.x * sign(positions[index].x);
        velocities[index].x *= - collisionDamping;
    }

    if (abs(positions[index].y) > halfBounds.y) {
        positions[index].y = halfBounds.y * sign(positions[index].y);
        velocities[index].y *= - collisionDamping;
    }

    positions[index].z = 0.0f;
    positions[index].w = 0.0f;
}

void main() {
    uint index = gl_GlobalInvocationID.x;
    if (index >= particleCount) return;

    positions[index] += velocities[index] * dt;
    HandleBoundaryCollisions(index);
}
