#version 430 core

layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

struct Entry {
    int index;
    uint key;
};

// Buffer declarations for particle data
layout(std430, binding = 0) buffer Positions { vec3 positions[]; };
layout(std430, binding = 1) buffer PredictedPositions { vec3 predictedPositions[]; };
layout(std430, binding = 2) buffer Velocities { vec3 velocities[]; };
layout(std430, binding = 3) buffer Densities { float densities[]; };
layout(std430, binding = 4) buffer NearDensities { float nearDensities[]; };
//layout(std430, binding = 5) buffer SpatialLookup { Entry spatialLookup[]; };
layout(std430, binding = 6) buffer StartIndices { uint startIndices[]; };
layout(std430, binding = 7) buffer SimulationParameters {
    float dt;
    float gravityAcceleration;
    float mass;
    float collisionDamping;
    float smoothingRadius;
    float targetDensity;
    float pressureMultiplier;
    float viscosityStrength;
    float nearDensityMultiplier;
    
    uint isInteracting;
    uint isPaused;
    vec3 inputPosition;
    float interactionRadius;
    float interactionStrength;

    uint particleCount;
    uint hashSize;
    float spacing;
    float particleRadius;
    float boundaryX;
    float boundaryY;
    float boundaryZ;
};

// Math constants
const uint MAX_INT = 0xffffffffu;
const float PI = 3.14159265359f;
const float EPSILON = 1e-6f;



const ivec2 cellOffsets[9] = ivec2[](
    ivec2(0, 0), ivec2(1, 0), ivec2(0, 1),
    ivec2(-1, 0), ivec2(0, -1), ivec2(1, 1),
    ivec2(-1, -1), ivec2(1, -1), ivec2(-1, 1)
);


void main() {
    uint index = gl_GlobalInvocationID.x;
    if (index >= positions.length()) return;

    velocities[index].y -= gravityAcceleration * dt; // Apply gravity
    predictedPositions[index] = positions[index] + velocities[index] * dt;

    //Update spatial lookup

    vec2(densities[index], nearDensities[index]) = CalculateDensity(index);
    vec3 pressureForce = CalculatePressureForce(index) / densities[index];
    vec3 viscosityForce = CalculateViscosityForce(index) / densities[index];
    vec3 totalForce = pressureForce + viscosityForce;
    velocities[index] += totalForce * dt;

    positions[index] += velocities[index] * dt;
}

void HandleBoundaryCollisions(uint index) {
    vec2 halfBounds = vec2(boundaryX  - particleRadius, boundaryY  - particleRadius);

    if (abs(positions[index].x) > halfBounds.x) {
        positions[index].x = halfBounds.x * sign(positions[index].x);
        velocities[index].x *= - collisionDamping;
    }

    if (abs(positions[index].y) > halfBounds.y) {
        positions[index].y = halfBounds.y * sign(positions[index].y);
        velocities[index].y *= - collisionDamping;
    }

    positions[index].z = 0.0f;
}

float SpikyPow2Kernel(float radius, float distance) {  
	if (distance > radius) return 0.0f;

	float v = radius - distance;
    float factor = 15 / (2 * PI * pow(radius, 5));
    return v * v * factor;
}

float SpikyPow2KernelDerivative(float radius, float distance) {
    if (distance > radius) return 0.0f;

    float v = radius - distance;
    float factor = 15 / (PI * pow(radius, 5));
    return -v * factor;
}

float SpikyPow3Kernel(float radius, float distance) {  
	if (distance > radius) return 0.0f;

	float v = radius - distance;
    float factor = 15 / (PI * pow(radius, 6));
    return v * v * v * factor;
}

float SpikyPow3KernelDerivative(float radius, float distance) {  
	if (distance > radius) return 0.0f;

	float v = radius - distance;
    float factor = 45 / (PI * pow(radius, 6));
    return -v * v * factor;
}

float Poly6Kernel(float radius, float distance) {  
	if (distance > radius) return 0.0f;

    float v = max(0.0f, radius * radius - distance * distance);
    float factor = 315 / (64 * PI * pow(abs(radius), 9));
	return v * v * v * factor;
}

float RandomFloat(uint seed) {
    return fract(sin(float(seed) * 12.9898) * 43758.5453);
}

vec3 GetRandomDirection3D(uint idx) {
    float x = RandomFloat(idx * 928371u) * 2.0 - 1.0; // [-1, 1]
    float y = RandomFloat(idx * 128931u) * 2.0 - 1.0; // [-1, 1]
    float z = 0.0f;
    return normalize(vec3(x, y, z));
}

ivec3 PositionsToCellCoord(vec3 point, float radius) {
    return ivec3(
        int(floor(point.x / radius)),
        int(floor(point.y / radius)),
        0
    );
}

uint HashCell(int x, int y) {
    const uint p1 = 73856093u;
    const uint p2 = 19349663u;
    return uint(x) * p1 ^ uint(y) * p2;
}

uint GetKeyFromHash(uint hash) {
    return hash % hashSize;
}

vec2 CalculateDensity(uint i) {
    ivec3 cellCoord = PositionsToCellCoord(predictedPositions[i], smoothingRadius);
    float density = 0.0;
    float nearDensity = 0.0;

    int centerX = cellCoord.x;
    int centerY = cellCoord.y;
    float sqrRadius = smoothingRadius * smoothingRadius;

    for (int k = 0; k < 9; ++k) {
        int offsetX = cellOffsets[k].x;
        int offsetY = cellOffsets[k].y;

        uint key = GetKeyFromHash(HashCell(centerX + offsetX, centerY + offsetY));
        uint cellStartIndex = uint(startIndices[key]);
        if (cellStartIndex == MAX_INT) continue;

        for (uint j = cellStartIndex; j < spatialLookup.length(); ++j) {
            if (uint(spatialLookup[j].key) != key) break;

            uint particleIndex = uint(spatialLookup[j].index);
            if (particleIndex == i) continue;

            vec3 offset = predictedPositions[particleIndex] - predictedPositions[i];
            float sqrDistance = dot(offset, offset);

            if (sqrDistance < sqrRadius) {
                float distance = sqrt(sqrDistance);
                density += SpikyPow2Kernel(smoothingRadius, distance) * mass;
                nearDensity += SpikyPow3Kernel(smoothingRadius, distance) * mass;
            }
        }
    }
    return vec2(density, nearDensity);
}

float DensityToPressure(float density) {
	float densityError = density - targetDensity;
	float pressure = pressureMultiplier * densityError;
    return pressure;
}

float NearDensityToPressure(float nearDensity)
{
    return nearDensityMultiplier * nearDensity;
}

vec3 CalculatePressureForce(int i) {
	vec3 pressureForce = vec3(0.0f);
	ivec3 cellCoord = PositionsToCellCoord(predictedPositions[i], smoothingRadius);
    int centerX = cellCoord.x;
	int centerY = cellCoord.y;
	float sqrRadius = smoothingRadius * smoothingRadius;

    for (int k = 0; k < 9; ++k) {
        int offsetX = cellOffsets[k].x;
        int offsetY = cellOffsets[k].y;

		uint key = GetKeyFromHash(HashCell(centerX + offsetX, centerY + offsetY));
		int cellStartIndex = startIndices[key];
		if (cellStartIndex == MAX_INT) continue;

        for (int j = cellStartIndex; j < spatialLookup.length(); ++j) {
            if (spatialLookup[j].key != key) break;
			
			int particleIndex = spatialLookup[j].index;
            if (particleIndex == i) continue;

			vec3 offset = predictedPositions[particleIndex] - predictedPositions[i];
			float sqrDistance = dot(offset, offset);

            if (sqrDistance < sqrRadius) {
				float distance = sqrt(sqrDistance);
                vec3 direction = (distance == 0) ? GetRandomDirection3D() : offset / distance;
                float slope = SpikyPow2KernelDerivative(smoothingRadius, distance);
				float nearSlope = SpikyPow3KernelDerivative(smoothingRadius, distance);
                float density = densities[particleIndex];
				float nearDensity = nearDensities[particleIndex];
				float sharedPressure = CalculateSharedPressure(densities[i], density); 
				float sharedNearPressure = CalculateNearSharedPressure(nearDensities[i], nearDensity);
                pressureForce += sharedPressure * slope * direction * mass / density;
                pressureForce += sharedNearPressure * nearSlope * direction * mass / nearDensity;
			}
		}
    }

	return pressureForce;
}

float CalculateSharedPressure(float densityA, float densityB) {
    float pressureA = DensityToPressure(densityA);
    float pressureB = DensityToPressure(densityB);
    return (pressureA + pressureB) / 2.0f;
}

float CalculateNearSharedPressure(float densityA, float densityB) {
    float pressureA = NearDensityToPressure(densityA);
    float pressureB = NearDensityToPressure(densityB);
    return (pressureA + pressureB) / 2.0f;
}

vec3 CalculateViscosityForce(int i) {
    vec3 viscosityForce = vec3(0.0f);
    vec3 cellCoord = PositionsToCellCoord(predictedPositions[i], smoothingRadius);
    int centerX = cellCoord.x;
    int centerY = cellCoord.y;
    float sqrRadius = smoothingRadius * smoothingRadius;
    for (int k = 0; k < 9; ++k) {
        int offsetX = cellOffsets[k].x;
        int offsetY = cellOffsets[k].y;
        uint key = GetKeyFromHash(HashCell(centerX + offsetX, centerY + offsetY));
        int cellStartIndex = startIndices[key];
        if (cellStartIndex == MAX_INT) continue;
        for (int j = cellStartIndex; j < spatialLookup.length(); ++j) {
            if (spatialLookup[j].key != key) break;
            int particleIndex = spatialLookup[j].index;
            if (particleIndex == i) continue;

            vec3 offset = predictedPositions[particleIndex] - predictedPositions[i];
            float sqrDistance = dot(offset, offset);
            if (sqrDistance < sqrRadius) {
                float distance = sqrt(sqrDistance);
				float influence = Poly6Kernel(smoothingRadius, distance);
                viscosityForce += (velocities[particleIndex] - velocities[i]) * influence;
            }
        }
    }

	return viscosityForce * viscosityStrength;
}

void ApplyInteractionForce(vec2 inputPos, float radius, float strength) {
    vec3 inputPos3D = vec3(inputPos, 0.0f); // extend to 3D for consistency
    vec3 cellCoord = PositionsToCellCoord(inputPos3D, smoothingRadius);
    int centerX = int(cellCoord.x);
    int centerY = int(cellCoord.y);

    float sqrRadius = radius * radius;

    for (int k = 0; k < 9; ++k) {
        int offsetX = cellOffsets[k].x;
        int offsetY = cellOffsets[k].y;

        uint key = GetKeyFromHash(HashCell(centerX + offsetX, centerY + offsetY));
        int cellStartIndex = startIndices[key];
        if (cellStartIndex == MAX_INT) continue;

        for (int j = cellStartIndex; j < spatialLookup.length(); ++j) {
            if (spatialLookup[j].key != key) break;

            int particleIndex = spatialLookup[j].index;
            vec2 offset = inputPos - vec2(positions[particleIndex]);  // 2D offset
            float sqrDist = dot(offset, offset);
            if (sqrDist < sqrRadius) {
                float dist = sqrt(sqrDist);
                vec2 direction = (dist <= EPSILON) ? vec2(0.0f) : offset / dist;
                float influence = 1.0f - dist / radius;
                vec2 force2D = direction * strength - vec2(velocities[particleIndex]) * influence;

                // Apply force to X and Y components
                velocities[particleIndex].x += force2D.x;
                velocities[particleIndex].y += force2D.y;
            }
        }
    }
}
